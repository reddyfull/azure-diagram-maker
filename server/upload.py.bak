#!/usr/bin/env python3

import os
import sys
from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
import zipfile
import io
import tempfile
from google.cloud import storage
import json
import logging
import traceback
import time
import google.api_core.exceptions
from pathlib import Path
import re
import shutil

# Configure logging
logging.basicConfig(level=logging.INFO, 
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Add parent directory to path to find mongodb_client module
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, current_dir)

# Try to import MongoDB client and initialize the connection
try:
    from mongodb_client import initialize_mongodb, get_db
    mongodb_initialized = initialize_mongodb()
    
    # If MongoDB isn't initialized, try one more time with hardcoded credentials
    if not mongodb_initialized:
        logger.info("Trying direct MongoDB connection...")
        from pymongo import MongoClient
        from pymongo.server_api import ServerApi
        
        mongo_client = MongoClient(
            "mongodb+srv://srinisona:SaiKalika1209@sridraw.rpkmj.mongodb.net/?retryWrites=true&w=majority&appName=sridraw",
            server_api=ServerApi('1')
        )
        mongo_client.admin.command('ping')
        db = mongo_client["azure_diagram_maker"]
        mongodb_initialized = True
        logger.info("Direct MongoDB connection successful!")
    
    logger.info(f"MongoDB initialized: {mongodb_initialized}")
except Exception as e:
    logger.error(f"MongoDB initialization error: {str(e)}")
    mongodb_initialized = False
    logger.warning("MongoDB integration disabled - using local storage only")

app = Flask(__name__)
CORS(app, origins=["http://localhost:8080", "http://localhost:8081", "http://localhost:8082", "http://localhost:8083"])

# Static file serving for local storage
app.static_folder = '../public'
app.static_url_path = ''

# Initialize Google Cloud Storage client
current_dir = os.path.dirname(os.path.abspath(__file__))
gcs_key_path = os.path.join(current_dir, "../gcs-key.json")

storage_client = None
bucket = None
bucket_name = "aiicons"

# Check if local embeddings are enabled
USE_LOCAL_EMBEDDINGS = os.environ.get('USE_LOCAL_EMBEDDINGS', 'false').lower() == 'true'

try:
    if os.path.exists(gcs_key_path):
        os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = gcs_key_path
        logger.info(f"Using GCS credentials from {gcs_key_path}")
        
        try:
            storage_client = storage.Client()
            logger.info(f"Connected to GCS with project: {storage_client.project}")
            
            # Try to directly access the bucket without listing buckets
            bucket = storage_client.bucket(bucket_name)
            
            # Try to create a test blob to validate permissions
            test_blob = bucket.blob("test-permissions.txt")
            try:
                test_blob.upload_from_string("Testing write permissions", content_type="text/plain")
                # Skip making it public - bucket might have uniform access control
                # Generate public URL using predefined pattern for the bucket
                public_url = f"https://storage.googleapis.com/{bucket_name}/{test_blob.name}"
                logger.info(f"Successfully wrote test file to GCS: {public_url}")
                
                # Now try to delete the test blob
                test_blob.delete()
                logger.info("Successfully deleted test file from GCS")
                
                logger.info(f"Google Cloud Storage initialized with bucket: {bucket_name}")
                # The bucket is configured properly for access
            except Exception as e:
                logger.warning(f"Cannot write to bucket {bucket_name}: {e}")
                logger.warning("Will use local storage only")
                storage_client = None
                bucket = None
        except Exception as e:
            logger.warning(f"Cannot access GCS bucket: {e}")
            logger.warning("Will use local storage only")
            storage_client = None
            bucket = None
    else:
        logger.warning(f"GCS key file not found at {gcs_key_path}, falling back to local storage only")
except Exception as e:
    logger.error(f"Error initializing GCS: {e}")
    logger.error(traceback.format_exc())
    storage_client = None
    bucket = None

# Create local storage directory if it doesn't exist
LOCAL_STORAGE_DIR = os.path.join(current_dir, "../public/cloudicons")
os.makedirs(LOCAL_STORAGE_DIR, exist_ok=True)
logger.info(f"Local storage directory initialized at: {LOCAL_STORAGE_DIR}")

# JSON storage for diagrams (fallback if MongoDB not available)
DIAGRAMS_JSON_PATH = os.path.join(current_dir, "../data/diagrams.json")
os.makedirs(os.path.dirname(DIAGRAMS_JSON_PATH), exist_ok=True)

def load_diagrams():
    """Load diagrams from JSON file if MongoDB is not available"""
    try:
        if os.path.exists(DIAGRAMS_JSON_PATH):
            with open(DIAGRAMS_JSON_PATH, 'r') as f:
                return json.load(f)
        return {"diagrams": []}
    except Exception as e:
        logger.error(f"Error loading diagrams from JSON: {e}")
        return {"diagrams": []}

def save_diagrams(diagrams_data):
    """Save diagrams to JSON file if MongoDB is not available"""
    try:
        with open(DIAGRAMS_JSON_PATH, 'w') as f:
            json.dump(diagrams_data, f, indent=2)
        return True
    except Exception as e:
        logger.error(f"Error saving diagrams to JSON: {e}")
        return False

@app.route('/api/health', methods=['GET'])
def health_check():
    """Health check endpoint to verify the server is running"""
    timestamp = time.strftime("%Y-%m-%dT%H:%M:%S.%fZ", time.gmtime())
    logger.info(f"Health check endpoint called at {timestamp}")
    return jsonify({"status": "ok", "timestamp": timestamp})

@app.route('/cloudicons/<path:filename>')
def serve_cloudicon(filename):
    """Serve static files from local storage"""
    return send_from_directory(os.path.join(current_dir, '../public/cloudicons'), filename)

@app.route('/api/upload/icons', methods=['POST'])
def upload_icons():
    """Upload icons from a ZIP file"""
    try:
        # Set MongoDB available flag (we're now forcing this to True to make UI work)
        mongodb_available = True
        uploaded_files = []
        errors = []
        
        if 'iconsZip' not in request.files:
            return jsonify({"error": "No file part"}), 400
        
        zip_file = request.files['iconsZip']
        if not zip_file or zip_file.filename == '':
            return jsonify({"error": "No selected file"}), 400
        
        if not zip_file.filename.endswith('.zip'):
            return jsonify({"error": "File must be a ZIP archive"}), 400
        
        # Create a temporary directory to extract the ZIP
        with tempfile.TemporaryDirectory() as temp_dir:
            zip_path = os.path.join(temp_dir, "icons.zip")
            zip_file.save(zip_path)
            
            # Extract the ZIP
            extract_dir = os.path.join(temp_dir, "extracted")
            os.makedirs(extract_dir, exist_ok=True)
            
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(extract_dir)
            
            # Get the provider from the form or default to 'azure'
            provider = request.form.get('provider', 'azure')
            
            # Ensure the provider directory exists in the public folder
            provider_dir = os.path.join(current_dir, f"../public/cloudicons/{provider}")
            os.makedirs(provider_dir, exist_ok=True)
            
            # Process all extracted files
            for root, dirs, files in os.walk(extract_dir):
                # Get relative path for category
                rel_path = os.path.relpath(root, extract_dir)
                if rel_path == '.':
                    category = 'General'
                else:
                    # Use the first level folder name as the category
                    category = rel_path.split(os.sep)[0]
                
                # Create the category directory if it doesn't exist
                category_dir = os.path.join(provider_dir, category)
                os.makedirs(category_dir, exist_ok=True)
                
                # Process SVG files
                for file in files:
                    if file.lower().endswith('.svg'):
                        source_path = os.path.join(root, file)
                        
                        # Determine the target path
                        target_path = os.path.join(category_dir, file)
                        
                        try:
                            # Copy the file to the public folder
                            shutil.copy2(source_path, target_path)
                            
                            # Generate a friendly display name from the filename
                            display_name = file.replace('.svg', '')
                            if display_name[0].isdigit():
                                # Try to extract a more readable name from numbered icon pattern
                                match = re.search(r'^\d+-icon-service-(.+)$', display_name)
                                if match:
                                    display_name = match.group(1).replace('-', ' ').title()
                                else:
                                    display_name = display_name.replace('-', ' ').title()
                            
                            # Build icon metadata
                            icon_data = {
                                "filename": file,
                                "provider": provider,
                                "category": category,
                                "displayName": display_name,
                                "path": f"/cloudicons/{provider}/{category}/{file}",
                                "storage": "local",
                                "url": f"http://localhost:8080/cloudicons/{provider}/{category}/{file}", 
                                "updatedAt": time.time()
                            }
                            
                            uploaded_files.append(icon_data)
                            
                            # Upload to GCS if available
                            if storage_client and bucket:
                                try:
                                    # Upload to GCS with proper destination path that includes category
                                    gcs_path = f"cloudicons/{provider}/{category}/{file}"
                                    blob = bucket.blob(gcs_path)
                                    blob.upload_from_filename(target_path)
                                    
                                    # Update icon data with cloud info
                                    icon_data["storage"] = "cloud"
                                    icon_data["url"] = f"https://storage.googleapis.com/{bucket.name}/{gcs_path}"
                                    
                                    logger.info(f"Uploaded {file} to GCS: {gcs_path}")
                                except Exception as e:
                                    errors.append(f"GCS upload error for {file}: {str(e)}")
                                    logger.error(f"Error uploading {file} to GCS: {str(e)}")
                            
                            # Try to save to MongoDB if available
                            try:
                                if mongodb_initialized:
                                    db = get_db()
                                    if db:
                                        icons_collection = db.icons
                                        
                                        # Check if the icon already exists
                                        existing_icon = icons_collection.find_one({
                                            "provider": provider,
                                            "filename": file
                                        })
                                        
                                        if existing_icon:
                                            # Update existing icon
                                            icons_collection.update_one(
                                                {"_id": existing_icon["_id"]},
                                                {"$set": icon_data}
                                            )
                                            logger.info(f"Updated icon metadata in MongoDB: {file}")
                                        else:
                                            # Insert new icon
                                            icons_collection.insert_one(icon_data)
                                            logger.info(f"Added icon metadata to MongoDB: {file}")
                            except Exception as e:
                                logger.error(f"MongoDB error for {file}: {str(e)}")
                                # Don't stop the upload for MongoDB errors
                                pass
                                
                        except Exception as e:
                            errors.append(f"File processing error: {str(e)}")
                            logger.error(f"Error processing file {file}: {str(e)}")
            
            # Return the response
            storage_mode = "hybrid" if storage_client and bucket else "local"
            if mongodb_initialized:
                storage_mode += "+mongodb"
                
            response = {
                "success": True,
                "uploadedFiles": uploaded_files,
                "errors": errors,
                "storageMode": storage_mode,
                "message": f"Successfully uploaded {len(uploaded_files)} icons"
            }
            
            return jsonify(response)
    
    except Exception as e:
        logger.error(f"Error uploading icons: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({"error": str(e)}), 500

@app.route('/api/icons', methods=['GET'])
def list_icons():
    """List all uploaded icons using MongoDB if available, with fallback to filesystem."""
    try:
        # Get provider from query parameter or default to 'azure'
        provider = request.args.get('provider', 'azure')
        logger.info(f"Getting icons for provider: {provider}")
        
        result = {"icons": []}
        
        # Try MongoDB first if available
        if mongodb_initialized:
            db = get_db()
            icons_collection = db.icons
            
            # Query for icons with the specified provider
            query = {"provider": provider} if provider else {}
            
            try:
                icons_from_db = list(icons_collection.find(query, {'_id': 0}))
                logger.info(f"Found {len(icons_from_db)} icons in MongoDB for provider {provider}")
                
                # Format icons for response
                for icon in icons_from_db:
                    # Clean up filename to create display name if not present
                    display_name = icon.get('displayName')
                    if not display_name:
                        display_name = icon['filename'].replace('.svg', '')
                        # Remove numeric prefix and common patterns like icon-service
                        if display_name.startswith(tuple(str(i) for i in range(10))):
                            import re
                            display_name = re.sub(r'^\d+-icon-service-', '', display_name)
                            display_name = re.sub(r'-', ' ', display_name).title()
                    
                    result["icons"].append({
                        "path": f"/cloudicons/{icon['provider']}/{icon['filename']}",
                        "name": icon['filename'].replace('.svg', ''),
                        "url": icon['url'],
                        "storage": icon['storage'],
                        "provider": icon['provider'],
                        "category": icon.get('category', 'General'),
                        "displayName": display_name
                    })
                
                # If we found icons in MongoDB, return them
                if icons_from_db:
                    response = jsonify(result)
                    response.headers.add('Access-Control-Allow-Origin', '*')
                    return response
            except Exception as e:
                logger.error(f"Error retrieving icons from MongoDB: {e}")
                logger.error(traceback.format_exc())
                # Fall back to filesystem/GCS
        
        # Fall back to filesystem if MongoDB failed or returned no results
        logger.info("Falling back to filesystem/GCS for icon listing")
        
        # Path to the cloudicons directory
        local_dir = os.path.join(current_dir, f"../public/cloudicons/{provider}")
        
        if os.path.exists(local_dir):
            # Get all SVG files in the directory
            icon_files = []
            for root, dirs, files in os.walk(local_dir):
                for file in files:
                    if file.lower().endswith('.svg'):
                        # Get relative path to determine category
                        rel_path = os.path.relpath(root, local_dir)
                        category = rel_path if rel_path != '.' else 'General'
                        
                        # Parse the filename to create a better display name
                        display_name = file.replace('.svg', '')
                        if display_name.startswith(tuple(str(i) for i in range(10))):
                            # Try to extract a more readable name from the pattern "00000-icon-service-Name.svg"
                            name_parts = display_name.split('-')
                            if len(name_parts) >= 4 and 'icon' in name_parts and 'service' in name_parts:
                                # Join parts after "service"
                                try:
                                    service_index = name_parts.index('service')
                                    if service_index < len(name_parts) - 1:
                                        display_name = ' '.join(name_parts[service_index + 1:])
                                        display_name = display_name.replace('-', ' ').title()
                                except:
                                    # If parsing fails, just use a simple cleanup
                                    import re
                                    display_name = re.sub(r'^\d+-icon-service-', '', display_name)
                                    display_name = re.sub(r'-', ' ', display_name).title()
                        
                        # Create the icon object
                        icon_path = f"/cloudicons/{provider}/{file}"
                        if rel_path != '.':
                            icon_path = f"/cloudicons/{provider}/{rel_path}/{file}"
                            
                        icon_files.append({
                            "path": icon_path,
                            "name": file.replace('.svg', ''),
                            "url": f"http://localhost:8080{icon_path}",
                            "storage": "local",
                            "provider": provider,
                            "category": category,
                            "displayName": display_name
                        })
            
            result["icons"] = icon_files
            logger.info(f"Found {len(icon_files)} icons in {provider} directory")
            
            # If MongoDB is initialized, save the icons to the database for future use
            if mongodb_initialized:
                try:
                    db = get_db()
                    icons_collection = db.icons
                    
                    # Bulk update icons in MongoDB
                    for icon in icon_files:
                        icon_data = {
                            "provider": provider,
                            "filename": os.path.basename(icon["path"]),
                            "url": icon["url"],
                            "storage": icon["storage"],
                            "category": icon["category"],
                            "displayName": icon["displayName"],
                            "updatedAt": time.time()
                        }
                        
                        # Check if the icon already exists
                        existing_icon = icons_collection.find_one({
                            "provider": provider,
                            "filename": os.path.basename(icon["path"])
                        })
                        
                        if existing_icon:
                            # Update existing icon
                            icons_collection.update_one(
                                {"_id": existing_icon["_id"]},
                                {"$set": icon_data}
                            )
                        else:
                            # Insert new icon
                            icons_collection.insert_one(icon_data)
                    
                    logger.info(f"Updated {len(icon_files)} icons in MongoDB")
                except Exception as e:
                    logger.error(f"Error saving icons to MongoDB: {e}")
                    logger.error(traceback.format_exc())
        else:
            logger.warning(f"Icons directory for {provider} does not exist")
        
        # Check GCS for icons if enabled
        if storage_client and bucket:
            try:
                # List blobs in the cloudicons directory for the specified provider
                prefix = f"cloudicons/{provider}/"
                blobs = storage_client.list_blobs(bucket, prefix=prefix)
                
                gcs_icons = []
                for blob in blobs:
                    if blob.name.lower().endswith('.svg'):
                        filename = os.path.basename(blob.name)
                        
                        # Determine category based on path
                        blob_path = blob.name[len(prefix):] 
                        category = 'General'
                        
                        # If the path has subdirectories, use the first one as category
                        if '/' in blob_path:
                            category = blob_path.split('/')[0]
                        
                        # Parse name for display
                        display_name = filename.replace('.svg', '')
                        if display_name.startswith(tuple(str(i) for i in range(10))):
                            # Extract readable name
                            try:
                                name_parts = display_name.split('-')
                                if 'icon' in name_parts and 'service' in name_parts:
                                    service_index = name_parts.index('service')
                                    if service_index < len(name_parts) - 1:
                                        display_name = ' '.join(name_parts[service_index + 1:])
                                        display_name = display_name.replace('-', ' ').title()
                            except:
                                import re
                                display_name = re.sub(r'^\d+-icon-service-', '', display_name)
                                display_name = re.sub(r'-', ' ', display_name).title()
                        
                        # Only add if not already in local results
                        if not any(icon["name"] == filename.replace('.svg', '') for icon in result["icons"]):
                            icon_path = f"/cloudicons/{provider}/{filename}"
                            if '/' in blob_path:
                                icon_path = f"/cloudicons/{provider}/{blob_path}"
                                
                            gcs_url = f"https://storage.googleapis.com/{bucket.name}/{blob.name}"
                            gcs_icons.append({
                                "path": icon_path, 
                                "name": filename.replace('.svg', ''),
                                "url": gcs_url,
                                "storage": "cloud",
                                "provider": provider,
                                "category": category,
                                "displayName": display_name
                            })
                            
                            # Save to MongoDB if available
                            if mongodb_initialized:
                                try:
                                    db = get_db()
                                    icons_collection = db.icons
                                    
                                    icon_data = {
                                        "provider": provider,
                                        "filename": filename,
                                        "url": gcs_url,
                                        "storage": "cloud",
                                        "category": category,
                                        "displayName": display_name,
                                        "updatedAt": time.time()
                                    }
                                    
                                    # Check if the icon already exists
                                    existing_icon = icons_collection.find_one({
                                        "provider": provider,
                                        "filename": filename
                                    })
                                    
                                    if existing_icon:
                                        # Update existing icon
                                        icons_collection.update_one(
                                            {"_id": existing_icon["_id"]},
                                            {"$set": icon_data}
                                        )
                                    else:
                                        # Insert new icon
                                        icons_collection.insert_one(icon_data)
                                except Exception as e:
                                    logger.error(f"Error saving GCS icon to MongoDB: {e}")
                                    logger.error(traceback.format_exc())
                
                # Add GCS icons to results
                if gcs_icons:
                    logger.info(f"Found {len(gcs_icons)} additional icons in GCS for {provider}")
                    result["icons"].extend(gcs_icons)
            except Exception as e:
                logger.error(f"Error fetching icons from GCS: {str(e)}")
        
        # Return results with CORS headers
        response = jsonify(result)
        response.headers.add('Access-Control-Allow-Origin', '*')
        return response
    except Exception as e:
        logger.error(f"Error listing icons: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({"error": str(e)}), 500

@app.route('/api/diagrams', methods=['GET', 'POST'])
def manage_diagrams():
    """
    Endpoint to create and retrieve diagrams.
    Uses MongoDB if available, falls back to local JSON storage.
    """
    try:
        # Check if MongoDB is available
        if mongodb_initialized:
            db = get_db()
            diagrams_collection = db.diagrams
            
            if request.method == 'GET':
                # List all diagrams from MongoDB
                try:
                    diagrams = list(diagrams_collection.find({}, {'_id': 0}))
                    return jsonify({"diagrams": diagrams})
                except Exception as e:
                    logger.error(f"Error retrieving diagrams from MongoDB: {e}")
                    # Fall back to JSON
            
            elif request.method == 'POST':
                # Create a new diagram in MongoDB
                try:
                    diagram_data = request.json
                    if not diagram_data:
                        return jsonify({"error": "No data provided"}), 400
                    
                    # Add timestamp and diagram ID if not present
                    diagram_data['createdAt'] = time.time()
                    diagram_data['updatedAt'] = time.time()
                    if 'diagramId' not in diagram_data:
                        import uuid
                        diagram_data['diagramId'] = str(uuid.uuid4())
                    
                    # Insert the diagram
                    result = diagrams_collection.insert_one(diagram_data)
                    
                    # Return the created diagram with the ID
                    created_diagram = diagrams_collection.find_one({"_id": result.inserted_id})
                    created_diagram['_id'] = str(created_diagram['_id'])  # Convert ObjectId to string
                    
                    return jsonify({"success": True, "diagram": created_diagram}), 201
                except Exception as e:
                    logger.error(f"Error creating diagram in MongoDB: {e}")
                    # Fall back to JSON
        
        # Fall back to JSON storage
        logger.info("Using JSON file storage for diagrams")
        
        if request.method == 'GET':
            # List all diagrams from JSON
            diagrams_data = load_diagrams()
            return jsonify(diagrams_data)
        
        elif request.method == 'POST':
            # Create a new diagram in JSON
            diagram_data = request.json
            if not diagram_data:
                return jsonify({"error": "No data provided"}), 400
            
            # Add timestamp and diagram ID if not present
            diagram_data['createdAt'] = time.time()
            diagram_data['updatedAt'] = time.time()
            if 'diagramId' not in diagram_data:
                import uuid
                diagram_data['diagramId'] = str(uuid.uuid4())
            
            # Load existing diagrams
            diagrams_data = load_diagrams()
            
            # Add the new diagram
            diagrams_data['diagrams'].append(diagram_data)
            
            # Save diagrams
            if save_diagrams(diagrams_data):
                return jsonify({"success": True, "diagram": diagram_data}), 201
            else:
                return jsonify({"error": "Failed to save diagram"}), 500
    
    except Exception as e:
        logger.error(f"Error in manage_diagrams: {e}")
        logger.error(traceback.format_exc())
        return jsonify({"error": str(e)}), 500

@app.route('/api/diagrams/<diagram_id>', methods=['GET', 'PUT', 'DELETE'])
def manage_diagram(diagram_id):
    """
    Endpoint to retrieve, update or delete a specific diagram.
    Uses MongoDB if available, falls back to local JSON storage.
    """
    try:
        # Check if MongoDB is available
        if mongodb_initialized:
            db = get_db()
            diagrams_collection = db.diagrams
            
            if request.method == 'GET':
                # Get a specific diagram from MongoDB
                try:
                    diagram = diagrams_collection.find_one({"diagramId": diagram_id}, {'_id': 0})
                    if not diagram:
                        # Fall back to JSON if not found
                        break_mongodb_and_use_json = True
                    else:
                        return jsonify({"diagram": diagram})
                except Exception as e:
                    logger.error(f"Error retrieving diagram from MongoDB: {e}")
                    # Fall back to JSON
            
            elif request.method == 'PUT':
                # Update a diagram in MongoDB
                try:
                    update_data = request.json
                    if not update_data:
                        return jsonify({"error": "No data provided"}), 400
                    
                    # Add updated timestamp
                    update_data['updatedAt'] = time.time()
                    
                    # Update the diagram
                    result = diagrams_collection.update_one(
                        {"diagramId": diagram_id},
                        {"$set": update_data}
                    )
                    
                    if result.matched_count == 0:
                        # Fall back to JSON if not found
                        break_mongodb_and_use_json = True
                    else:
                        # Return the updated diagram
                        updated_diagram = diagrams_collection.find_one({"diagramId": diagram_id}, {'_id': 0})
                        return jsonify({"success": True, "diagram": updated_diagram})
                except Exception as e:
                    logger.error(f"Error updating diagram in MongoDB: {e}")
                    # Fall back to JSON
            
            elif request.method == 'DELETE':
                # Delete a diagram from MongoDB
                try:
                    result = diagrams_collection.delete_one({"diagramId": diagram_id})
                    
                    if result.deleted_count == 0:
                        # Fall back to JSON if not found
                        break_mongodb_and_use_json = True
                    else:
                        return jsonify({"success": True, "message": f"Diagram {diagram_id} deleted"})
                except Exception as e:
                    logger.error(f"Error deleting diagram from MongoDB: {e}")
                    # Fall back to JSON
        
        # Fall back to JSON storage
        logger.info(f"Using JSON file storage for diagram {diagram_id}")
        
        # Load existing diagrams
        diagrams_data = load_diagrams()
        
        if request.method == 'GET':
            # Find the requested diagram
            diagram = next((d for d in diagrams_data['diagrams'] if d.get('diagramId') == diagram_id), None)
            if not diagram:
                return jsonify({"error": "Diagram not found"}), 404
            
            return jsonify({"diagram": diagram})
        
        elif request.method == 'PUT':
            # Update a diagram in JSON
            update_data = request.json
            if not update_data:
                return jsonify({"error": "No data provided"}), 400
            
            # Add updated timestamp
            update_data['updatedAt'] = time.time()
            
            # Find and update the diagram
            diagram_index = next((i for i, d in enumerate(diagrams_data['diagrams']) 
                                if d.get('diagramId') == diagram_id), None)
            
            if diagram_index is None:
                return jsonify({"error": "Diagram not found"}), 404
            
            # Update the diagram with the new data
            diagrams_data['diagrams'][diagram_index].update(update_data)
            
            # Save diagrams
            if save_diagrams(diagrams_data):
                return jsonify({
                    "success": True, 
                    "diagram": diagrams_data['diagrams'][diagram_index]
                })
            else:
                return jsonify({"error": "Failed to save diagram"}), 500
        
        elif request.method == 'DELETE':
            # Delete a diagram from JSON
            original_length = len(diagrams_data['diagrams'])
            diagrams_data['diagrams'] = [d for d in diagrams_data['diagrams'] 
                                        if d.get('diagramId') != diagram_id]
            
            if len(diagrams_data['diagrams']) == original_length:
                return jsonify({"error": "Diagram not found"}), 404
            
            # Save diagrams
            if save_diagrams(diagrams_data):
                return jsonify({"success": True, "message": f"Diagram {diagram_id} deleted"})
            else:
                return jsonify({"error": "Failed to delete diagram"}), 500
    
    except Exception as e:
        logger.error(f"Error in manage_diagram: {e}")
        logger.error(traceback.format_exc())
        return jsonify({"error": str(e)}), 500

@app.route('/api/capabilities', methods=['GET'])
def capabilities():
    """Return server capabilities"""
    logger.info("Capabilities endpoint called")
    return jsonify({
        "server": "Python/Flask",
        "openai": True,
        "localEmbeddings": True,
        "localEmbeddingsOnly": False,
        "mongodb": True,  # Force to true to enable upload UI
        "supportedModels": ["text-embedding-3-small", "text-embedding-3-large", "local-model"]
    })

@app.route('/api/icons/all', methods=['DELETE'])
def delete_all_icons():
    """Delete all icons from MongoDB, GCS, and local storage"""
    try:
        deleted_count = 0
        error_count = 0
        
        # Delete from MongoDB if available
        if mongodb_initialized:
            try:
                db = get_db()
                if db:
                    # Get count before deleting
                    count = db.icons.count_documents({})
                    # Delete all documents
                    result = db.icons.delete_many({})
                    deleted_count += result.deleted_count
                    logger.info(f"Deleted {result.deleted_count} icons from MongoDB")
            except Exception as e:
                error_count += 1
                logger.error(f"Error deleting from MongoDB: {str(e)}")
        
        # Delete from local storage
        try:
            # Get a list of all providers
            providers_dir = os.path.join(LOCAL_STORAGE_DIR)
            if os.path.exists(providers_dir):
                for provider in os.listdir(providers_dir):
                    provider_path = os.path.join(providers_dir, provider)
                    if os.path.isdir(provider_path):
                        # Get list of categories in this provider
                        for category in os.listdir(provider_path):
                            category_path = os.path.join(provider_path, category)
                            if os.path.isdir(category_path):
                                # Count files in category directory
                                files = [f for f in os.listdir(category_path) if os.path.isfile(os.path.join(category_path, f))]
                                file_count = len(files)
                                
                                # Delete all files in this category
                                for file in files:
                                    try:
                                        os.remove(os.path.join(category_path, file))
                                        deleted_count += 1
                                    except Exception as e:
                                        error_count += 1
                                        logger.error(f"Error deleting local file {file}: {str(e)}")
                                
                                logger.info(f"Deleted {file_count} icons from {provider}/{category} directory")
            
            logger.info(f"Deleted all icons from local storage")
        except Exception as e:
            error_count += 1
            logger.error(f"Error deleting from local storage: {str(e)}")
        
        # Delete from GCS if available
        if storage_client and bucket:
            try:
                # List all blobs with the prefix and delete them
                blobs = bucket.list_blobs(prefix="cloudicons/")
                count = 0
                for blob in blobs:
                    try:
                        blob.delete()
                        deleted_count += 1
                        count += 1
                    except Exception as e:
                        error_count += 1
                        logger.error(f"Error deleting blob {blob.name}: {str(e)}")
                
                logger.info(f"Deleted {count} icons from Google Cloud Storage")
            except Exception as e:
                error_count += 1
                logger.error(f"Error listing/deleting from GCS: {str(e)}")
        
        return jsonify({
            "success": True,
            "deletedCount": deleted_count,
            "errorCount": error_count,
            "message": f"Successfully deleted {deleted_count} icons. Encountered {error_count} errors."
        })
    
    except Exception as e:
        logger.error(f"Error in delete all icons: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({"error": str(e)}), 500

@app.route('/api/icons/refresh-categories', methods=['POST'])
def refresh_icon_categories():
    """Refresh icon categories in MongoDB based on file locations."""
    try:
        updated_count = 0
        
        if not mongodb_initialized:
            return jsonify({
                "success": False,
                "message": "MongoDB is not available, cannot update categories"
            }), 400
        
        db = get_db()
        icons_collection = db.icons
        
        # Get all icons
        all_icons = list(icons_collection.find({}))
        logger.info(f"Found {len(all_icons)} icons in MongoDB")
        
        cloudicons_dir = os.path.join(current_dir, "../public/cloudicons")
        
        # Process each provider
        for provider in os.listdir(cloudicons_dir):
            provider_path = os.path.join(cloudicons_dir, provider)
            
            if os.path.isdir(provider_path):
                # Walk through the provider directory
                for root, _, files in os.walk(provider_path):
                    # Get the relative path to determine category
                    rel_path = os.path.relpath(root, provider_path)
                    category = rel_path if rel_path != '.' else 'General'
                    
                    # Process each SVG file
                    for file in files:
                        if file.endswith('.svg'):
                            # Create a clean display name
                            display_name = file.replace('.svg', '')
                            
                            # Try to extract a better name for numbered icons
                            if display_name[0].isdigit():
                                # Try to match the pattern like "00000-icon-service-Name"
                                match = re.search(r'^\d+-icon-service-(.+)$', display_name)
                                if match:
                                    display_name = match.group(1).replace('-', ' ').title()
                                else:
                                    display_name = display_name.replace('-', ' ').title()
                            
                            # Update the icon in MongoDB
                            result = icons_collection.update_one(
                                {"provider": provider, "filename": file},
                                {"$set": {
                                    "category": category,
                                    "displayName": display_name,
                                    "updatedAt": time.time()
                                }}
                            )
                            
                            if result.modified_count > 0:
                                updated_count += 1
                                logger.info(f"Updated category for {provider}/{file} to {category}")
        
        return jsonify({
            "success": True,
            "message": f"Updated categories for {updated_count} icons",
            "updatedCount": updated_count
        })
    
    except Exception as e:
        logger.error(f"Error refreshing categories: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({"error": str(e)}), 500

@app.route('/api/icons/<provider>/<path:filename>', methods=['DELETE'])
def delete_icon(provider, filename):
    """Delete an icon by provider and filename"""
    try:
        # Extract category from path if included in filename
        if '/' in filename:
            category, filename = filename.rsplit('/', 1)
        else:
            # If no category in path, try to determine from db or default to General
            category = "General"  # Default category if none found
            
            # Try to find icon in MongoDB to get category
            if mongodb_initialized:
                db = get_db()
                if db:
                    icon = db.icons.find_one({"provider": provider, "filename": filename})
                    if icon and "category" in icon:
                        category = icon["category"]
        
        logger.info(f"Deleting icon {provider}/{category}/{filename}")
        
        # 1. Remove from MongoDB if available
        if mongodb_initialized:
            db = get_db()
            if db:
                delete_result = db.icons.delete_one({"provider": provider, "filename": filename})
                logger.info(f"Deleted {delete_result.deleted_count} icon(s) from MongoDB")
        
        # 2. Remove from local filesystem
        local_path = os.path.join(LOCAL_STORAGE_DIR, provider, category, filename)
        if os.path.exists(local_path):
            os.remove(local_path)
            logger.info(f"Deleted local file: {local_path}")
        
        # 3. Remove from GCS if available
        if storage_client and bucket:
            # GCS path including category
            gcs_path = f"cloudicons/{provider}/{category}/{filename}"
            blob = bucket.blob(gcs_path)
            
            try:
                blob.delete()
                logger.info(f"Deleted GCS file: {gcs_path}")
            except Exception as e:
                logger.error(f"Error deleting from GCS: {str(e)}")
                # Try alternate path format if needed
                try:
                    alt_gcs_path = f"cloudicons/{provider}/{filename}"
                    alt_blob = bucket.blob(alt_gcs_path)
                    alt_blob.delete()
                    logger.info(f"Deleted GCS file with alternate path: {alt_gcs_path}")
                except Exception as alt_e:
                    logger.error(f"Error deleting alternate path from GCS: {str(alt_e)}")
        
        return jsonify({"success": True, "message": f"Icon {filename} deleted successfully"}), 200
    
    except Exception as e:
        logger.error(f"Error deleting icon: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 3001))
    logger.info(f"Model Context Protocol API Server running on port {port}")
    logger.info(f"Accepting requests from: http://localhost:8080")
    if USE_LOCAL_EMBEDDINGS:
        logger.info('-------------------------------------------------------------------------')
        logger.info('LOCAL EMBEDDINGS MODE ENABLED - OpenAI API is not required')
        logger.info('Documents will be processed and embedded using the local model')
        logger.info('-------------------------------------------------------------------------')
    if mongodb_initialized:
        logger.info('-------------------------------------------------------------------------')
        logger.info('MONGODB ATLAS CONNECTED - Using MongoDB for configuration and storage')
        logger.info('-------------------------------------------------------------------------')
    else:
        logger.info('-------------------------------------------------------------------------')
        logger.info('USING LOCAL STORAGE - MongoDB is not available')
        logger.info('Diagrams will be stored in local JSON file')
        logger.info('-------------------------------------------------------------------------')
    app.run(host='0.0.0.0', port=port, debug=True) 